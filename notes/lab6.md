# 操作系统原理实验报告

## **实验名称:**   实验六 并发与锁机制

**授课教师：**  张青

**学生姓名:**   黄世杰

**学生学号:**   21307038

### **1.** **实验要求**

完成4个Assignment：Assignment 1: 代码复现；Assignment 2: 生产者-消费者问题；Assignment 3：线程调度切换的秘密

### **2.** **实验过程**

#### **Assignment 1**

**A.1.1 代码复现**

根据实验报告中的自旋锁和信号量的介绍和实现复现一遍，并使用他们来解决代码中的同步互斥问题，如消失的芝士汉堡问题

**A.1.2 锁机制的实现** 

除了用实验手册上面的 `xchg` 指令来原子交换，还可以通过 `lock bts` 指令来原子测试和置位，具体来说：会将指定内存/寄存器的第某一位位放到 eflags 寄存器中的 CF（第该位）中，同时对该内存/寄存器的值的那一位置1，具体实现可以看下面的关键代码和结果。

#### Assignment 2

**A.2.1 Race Condition**

对于经典的生产者消费者问题，如多个生产者和多个消费者共同往一个循环的优先队列中放入/取出值，需要保证：
1. 生产者之间一次只能有一个修改缓冲区队列，
2. 消费者之间一次也只能有一个修改缓冲区队列，
3. 队列满了的话生产者需要等待，
4. 队列空了的话消费者需要等待

如果不加信号量来保证上面4个条件，会出现同步互斥的相关问题

**A.2.2 信号量解决方法**

为资源数目提供信号量 `full` （内部值初始为0） ，空闲空间数目提供信号量 `empty`（内部值初始为空闲缓冲区数），同时为缓冲区互斥访问提供一个信号量 `mutex`（内部值为1，提供互斥作用）

生产者进入前先 `empty.P()`获得空闲访问资源，然后 `mutex.P()`获得缓冲区互斥访问资源，结束访问后 `mutex.V()` 释放互斥量，然后 `full.V()` 增加资源数量

消费者进入前先 `full.P()`获得已有资源访问，然后 `mutex.P()`获得缓冲区互斥访问资源，结束访问后 `mutex.V()` 释放互斥量，然后 `empty.V()` 增加空闲区数量

#### Assignment 3

**A.3.1. 初步解决问题** 

根据理论教材中的简单的方法：为每一根筷子分配一个信号量，其中每个信号量里面的资源值为1，因为一根筷子只能被一个人用，然后哲学家需要依次连续获取他左边的和右边的筷子才能进入临界区，然后出互斥区的时候要释放右边和左边的筷子（虽然这种方法保证两个邻居之间不会同时进食，但可能会出现死锁，在A.3.2中详细说明）

**A.3.2. 死锁解决方法**

A.3.1.中的方法在所有哲学家都同时拿起左边的筷子，即每一个哲学家在获取左边筷子的信号量之后被调度，最后所有筷子信号量为0，出现死锁。

1. 法一：同时只允许4个哲学家拿起左边的筷子，即多加一个信号量，其资源数为4，在哲学家拿左边筷子之前要先获取该信号量的资源。当4个哲学家同时拿起左边的筷子时，该信号量资源为0，第五个哲学家就无法获得左边的筷子，需要等到其中一个哲学家再获取右边的筷子并释放后才能获得。
2. 法二：使用AND信号量的机制，如果某个哲学家想要获得筷子的时候，一定要获得左右两边的筷子的时候其他哲学家才能获得筷子，否则其他哲学家只能等待或者释放已经获得的筷子。可以通过增加一个信号量，其资源数为1来让哲学家获得筷子之前先获得该信号量，然后其他哲学家只能等他获得两根筷子（或释放筷子）并释放该信号量后才能获取筷子

### 3.关键代码

#### Assignment 1

**A.1.1 代码复现**

**1、自旋锁**

1. 在 inlcude/sync.h 头文件中定义结构 `SpinLock` ，其内部有一个变量 `bolt` 用来实现锁结构

![[Pasted image 20230512151903.png|300]]

2. 在 src/utils 文件中添加 `asm_atomic_exchange()` 汇编函数，通过 `xchg` 原子指令交换寄存器和内存中的值（第一个参数要是局部变量，第二个参数时要修改的全局变量）

![[Pasted image 20230512150911.png|500]]

3. 在 kernel 文件夹下添加 sync.cpp 文件，实现了 spinlock 的使用函数（通过函数内部汇编中的原子指令来修改全局变量 `bolt` 来获得锁）

![[Pasted image 20230512152722.png]]

**2、信号量** 

1. 在 inlcude/sync.h 头文件中定义结构 `Semaphore` ，其内部的 `counter` 用来表示资源数，`waitting` 来表示阻塞队列，`semLock` 来保证对 `counter` 变量的访问是互斥的

![[Pasted image 20230512152813.png|400]]

2. 在 src/sync.cpp 文件中添加有关 `Semaphore` 信号量的函数实现

![[Pasted image 20230512160341.png]]

3. 在 kernel/program.cpp 增加唤醒阻塞线程的函数

![[Pasted image 20230512153957.png]]


**A.1.2 锁机制的实现** 

1. 在 utils/asm_utils.asm 文件下添加自定义的 `asm_atomic_bts()` 函数，通过 `lock bts [ebx], 0`  (其中ebx为参数 bolt 的地址) 原子指令来测试并设置内存中的值，具体步骤如下：
	1. 将 bolt 的第0位放到 eflags 寄存器中的 CF（第0位）中
	2. 将 bolt 的第0位置1
2. 之后我将 CF 寄存器的值读到 eax 寄存器中并返回：如果bolt的值为1就会返回1，为0就会返回0
3. 通过原子设置和读取bolt的值能够实现互斥的功能

![[Pasted image 20230512175155.png]]

2. 修改 kernel/sync.cpp 中使用自己实现的能够完成原子操作的函数来测试（这样可以通过返回值判断是否需要循环，就可以不用局部变量）
	* 如果 `asm_atomic_bts()` 返回值为0，表示CF寄存器，也就是bolt原来的值为0，那么就可以退出循环获得锁
	* 如果返回值为 1，表示CF寄存器，也就是bolt原来的值为1，那么就不断循环等待

![[Pasted image 20230512175049.png]]

#### Assignment 2

**A.2.1 Race Condition**

缓冲区使用的是环形队列，`in` 和 `out` 都是递增的，不过在对缓冲区访问的时候要 % BUFFER_SIZE

![[Pasted image 20230512220917.png]]

**A.2.2 信号量解决方法**

生产者进入前先 `empty.P()`获得空闲访问资源，然后 `mutex.P()`获得缓冲区互斥访问资源，结束访问后 `mutex.V()` 释放互斥量，然后 `full.V()` 增加资源数量

消费者进入前先 `full.P()`获得已有资源访问，然后 `mutex.P()`获得缓冲区互斥访问资源，结束访问后 `mutex.V()` 释放互斥量，然后 `empty.V()` 增加空闲区数量

![[Pasted image 20230512220719.png]]

#### Assignment 3

**A.3.1. 初步解决问题** 

我这里在线程进入互斥区的时候让他 `sleep()` 使得能够被调度，不然线程在一个时间片内执行时间过长，很难碰到在互斥区中被调度的情况，所以我这里模拟了被抢占的情况

![[Pasted image 20230513172137.png]]

**A.3.2. 死锁解决方法

出现死锁：在A.3.1.的代码中的线程获得左边的筷子后通过 `sleep()` 来调度切换，然后所有哲学家都获得了左边的筷子，出现死锁

![[Pasted image 20230513172020.png]]

1. 最多允许4个哲学家获得左边的筷子的解决方法：所有线程在最开始先获得left信号量的资源（left总共有4个资源），结束后释放left，可以防止死锁发生

![[Pasted image 20230513171959.png]]

2. 当一个哲学家获得筷子的时候一定要获得左右的筷子之后才能让其他哲学家获得筷子，通过增加信号量 `mutex`（只有1个资源，当作互斥锁）可以实现

![[Pasted image 20230513171753.png]]


### **4.实验结果**

#### Assignment 1

**A.1.1 代码复现**

**1、自旋锁**

可以看到，一开始 `mother` 线程获得了锁，在制作 burger 的时候 `jesus` 线程想要获得锁，但无法获得，等到 `mother` 线程执行结束释放锁的时候，`jesus` 线程才能够获得锁

![[Pasted image 20230512152509.png]]

**2、信号量** 

`mother` 线程先 P 获得资源进入临界区，如何 `boy` 线程 P 被阻塞，等到 `mother` 线程执行完毕后再唤醒 `boy` 线程来执行

![[Pasted image 20230512160108.png]]

**A.1.2 锁机制的实现

下面是测试锁的结果：`mother` 线程获得锁后 bolt 的值被设置为1，之后 `boy` 线程获得锁失败，等到 `mother` 线程结束释放锁后 `boy` 线程才成功获得锁并执行

![[Pasted image 20230512174913.png]]

下面是信号量中使用了锁的测试，也成功了

![[Pasted image 20230512180559.png]]

#### Assignment 2 

**A.2.1 Race Condition**

最终输出的 `in` 的值为3，每个生产者线程迭代3次，总共三个生产者线程，本应该是9；消费者线程也是有3个每个迭代3次，最终 `out` 输出本应该是9

![[Pasted image 20230512215240.png]]

**A.2.2 信号量解决方法**

可以看到最终输出的时候 `in = 9`, `out = 9` ，符合互斥

![[Pasted image 20230512215913.png]]

#### Assignment 3 

**A.3.1. 初步解决问题** 

使用5个信号量分别代表5根筷子，每个信号量的资源数为1，可以看到每次获得的筷子都不会重复，说明该方法可以保证不会同时获得两根一样的筷子（但可能会出现死锁，在A.3.2中给出）

![[Pasted image 20230513172343.png]]

**A.3.2. 死锁解决方法

出现死锁的情况：所有哲学家获得左边的筷子后停住了，出现死锁

![[Pasted image 20230513163150.png]]

1. 最多允许4个哲学家获得左边的筷子的解决方法：可以看到一开始4个线程都获得了左边的筷子，第5个线程无法获得左边的筷子，之后第4个线程再获得右边的筷子，之后释放其左边和右边的筷子，然后第五个线程就可以获得其左边的筷子，后面的情况都保证了不会同时获得两根筷子，且不会出现死锁。

![[Pasted image 20230513172056.png]]

2. 每个哲学家获得筷子之前就获得互斥锁（一个资源的信号量），一定要等到其获得两根筷子的时候才能释放该互斥锁，然后其他哲学家才能获得锁来获得筷子（或者释放以获得的两根筷子）：从代码结果中可以看出哲学家1鲜活的筷子0和1，之后哲学家3才能获得筷子2和3，然后哲学家5获得筷子4，这时其还没有释放互斥锁（要等到获得两根筷子才能释放），其他哲学家只能等待或者释放已获得的两根筷子，所以之后哲学家1释放筷子0和1，然后哲学家5继续获得筷子0，然后释放锁，哲学家2才能获得筷子。

![[Pasted image 20230513170459.png]]

### 5.  总结

本次实验中，加深了我对锁和信号量的理解，明白了如何根据原子指令 `xchg` 和 'lock bts' 来实现自旋锁；学会了用信号量解决生产者-消费者问题；同时面对哲学家问题，从普通方法解决相邻两个哲学家不会同时拿筷子，然后发现有死锁情况，经过分析后通过两种方法来解决死锁问题，让我对同步互斥问题有了更深刻的理解。