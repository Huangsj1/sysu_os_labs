# 操作系统原理实验报告

## **实验名称:**   实验三 从实模式到保护模式

**授课教师：**  张青

**学生姓名:**   黄世杰

**学生学号:**   21307038

### **1.** **实验要求**

完成3个Assignment：Assignment 1 用LBA和CHS方式分别复现Example1, Assignment 2 复现Example2，学习使用gdb, Assignment 3 改造Lab2-A4为保护模式下32位代码，在保护模式下运行

### **2.** **实验过程**

#### **Assignment 1**

**1.1**

参考实验指导的pdf，复现Example1 Bootloader的加载

1. 在bootloader.asm中编写打印"run bootloader"的汇编程序
2. 在mbr.asm中使用LBA模式读取硬盘的代码，加载bootloader到地址0x7e00处，并跳转到0x7e00来执行bootloader程序

**1.2**

修改LBA28模式位CHS模式，通过BIOS中断来读取磁盘到内存中

* 以C、H、S分别表示当前硬盘的柱面号、磁头号、扇区号，  
  CS、HS、SS分别表示起始柱面号、磁头号、扇区号，  
  PS表示每磁道扇区数，PH表示每柱面总的磁道数。   
	  1. 则**C/H/S到LBA**的转换公式为：  
		LBA=（C–CS）×PH×PS+（H–HS）×PS+（S–SS）  
		2. 从**LBA到C/H/S**的转换公式为：  
	   C = LBA /（PH×PS）+CS  
	   H =（LBA / PS）% PH+HS  
	   S = LBA % PS+SS
* 起始柱面CS=0、磁道HS=0、扇区SS=1;  
  一个柱面磁道数目PH=18，一个磁道扇区数目PS=63;  
  C=LBA/(PH*PS)+CS=0;  
  H=(LBA/PS)%PH+HS=0;  
  S=LBA%PS+SS=2;  
  与磁盘有关的中断int 13h：  
  入口：ah=2;  
  扇区数：al=5;  
  起始柱面：ch=0;  
  起始磁道：dh=0;  
  起始扇区：cl=2;  
  驱动器：dl=80h;  
  缓冲区：es:bx=0x0000:0x7e00

#### Assignment 2

复现Example 2，使用gdb在进入保护模式时（即在bootloader中进入保护模式时）的4个重要步骤设置断点，分析四个步骤

* 启动gdb，加载符号表，在bootloader处下断点，执行到断点处用si单步进入执行汇编，同时layout查看寄存器和源代码，分析四个步骤

#### Assignment 3

改造“Lab2-Assignment 4"为32位代码，在保护模式后执行自定义的汇编程序

* 将代码改成32位后并且编译成32位的可执行文件后，将改.bin文件**加载到6号磁盘**中，在bootloader进入保护模式后**加载该6号磁盘到内存地址0xa000**中，再**跳转到该地址执行**我的汇编代码

1. 由于当前进入保护模式，寻址方式变成了由段寄存器中的段选择子来在GDT中得到段基地址 + 偏移地址，所以不用再修改段寄存器（在bootloader中已经设置好了）
2. 清屏并且在一个循环中不断打印字符实现字符弹射

### **3.关键代码**

#### Assignment  1

**1.1**
mbr.asm
![[Pasted image 20230327110917.png|600]]

bootloader.asm
![[Pasted image 20230327111025.png|600]]

**1.2**
改后的mbr.asm
![[Pasted image 20230327111120.png|600]]


#### Assignment 2

boot.inc
![[Pasted image 20230327111218.png|600]]

mbr.asm
![[Pasted image 20230327111733.png|600]]

bootloader.asm
![[Pasted image 20230327111856.png|600]]


#### Assignment 3

mbr.asm
![[Pasted image 20230327112131.png|600]]

bootloader.asm
![[Pasted image 20230327112230.png|600]]

bullet.asm
![[Pasted image 20230327112348.png|600]]

### **4.实验结果**

#### Assignment 1

1.1
![[8d1b78e1ed9d29150271402bd56f5d8.png|600]]

1.2
![[05f8e71d2d71714df344fc9f3f030fe.png|600]]

#### Assignment 2 复现Example2和使用gdb看4个进入保护模式的步骤

复现Example2
![[67594e244de374621eb5fffe00f61b8.png|600]]

1 查看0x8800处的GDT
![[6bf1634d233e89e9d6c486f9ac6721b.png|600]]

2 打开第21根地址线，al第二位为1
![[34d0d8bdd8415ca61cd18fc4a46a534.png|600]]

3 cr0寄存器的值在eax中，最低为被修改为了1，开启保护模式
![[ccde27377c3f1d144a5262060942e1f.png|600]]

4 数据段描述符为第1个，每个描述符占8个字节，所以下标为0x8，即ds和es的值都为0x8；堆栈段描述符为第2个，下标为0x10，即ss值为0x10；代码段描述符为第4个，下标为0x20，即cs值为0x20
![[a3e7d100ee332cb57fb66bc723a1bdd.png|600]]

#### Assignment 3 改造Lab2-A4为保护模式下32位代码，在保护模式下运行
![[9d26daa66603b3ee99d00145312dd55.png|600]]


### 5.  **课后思考题**

1. bootloader的作用是用来加载操作系统的内核到内存中，同时还会初始化硬件以确保操作系统能够正常运行，最后再转移控制权到操作系统中执行操作系统代码。（因为MBR只有512字节，能完成的工作有限，不足以加载内核到内存中，所以需要加载bootloader来完成其他MBR没法完成的工作）
2. 处理器和外围设备交互的方式：①程序查询方式（处理器通过轮询或查询方式向设备读取或者写入数据）；②中断方式；③直接存储器访问方式DMA（设备直接访问内存）；④内存映射I/O方式（将设备寄存器和内存映射在一起，处理器可以直接读取和写入这些寄存器）   
   LBA属于程序查询方式，因为处理器要向硬盘发送指令操作时，需要在对应的I/O端口放入命令和数据，等待外围设备处理后再取出数据
3.  对于in/out对端口进行操作时，端口的地址可以是立即数也可以是寄存器的值，对于**立即数**来说只能是*8位立即数*，而0x1f3有12位，超出了限制；对于**寄存器**来说是*16位地址*，所以要用寄存器dx来作为out端口的地址
4. **段选择子**：在保护模式下段寄存器中存储的是段选择子，通过段选择子来在全局描述符表中找到对应的段描述符从而得到基地址；  
    **段描述符**：有64位，其中包含了段的32位基地址，段界限以及各种不同用处的标志位；  
    **GDT**：global descriptor table全局描述符表，相当于一个数组，里面的元素都是段描述符；  
    **GDTR**：48位的寄存器，低16位是GDT的界限，高32位是GDT的基地址
5. 线性地址就是程序中的基地址+偏移地址（如寄存器的si : ip），也相当于虚拟内存地址。  
   线性地址是每一个进程所分配的在4GB内所要访问的的地址，是虚拟地址；物理地址是内存中的真实的地址，线性地址要经过映射（如页表）才能得到物理地址。
6. equ是汇编伪指令，有点类似c的宏定义（如HAHA equ 6，所用到的HAHA全部替换成6），不会出现在最终的bin格式文件中。
7. **数据段描述符**：  高32位：0x00cf9200，低32位：0x0000ffff
	* 段线性基地址：三部分组成，为0x00000000
	* G=1，表示段界限以4KB为单位
	* D/B=1，表示操作数大小为32位
	* L=0，表示32位代码
	* AVL，保留位，不关心，置0即可
	* 段界限由两部分组成，共20位。结合段界限和粒度    
	  最大偏移量 = （段界限+1）\* 粒度 = (0xfffff+1)\*4KB = 4GB，  
	   表示范围：0x00000000~0xffffffff
	* P=1，表示段存在
	* DPL=0，表示最高优先级
	* S=1，表示数据段
	* TYPE=  2，读写，向上扩展
	  
   **栈段描述符**：  高32位：0x00409600，低32位：0x00000000
	   * 段线性基地址：三部分组成，为0x00000000
	* G=0，表示段界限以字节为单位
	* D/B=1，表示操作数大小为32位
	* L=0，表示32位代码
	* AVL，保留位，不关心，置0即可
	* 段界限由两部分组成，共20位。结合段界限和粒度：  
	  最小偏移量 = （段界限+1）\* 粒度 = (0x00000+1)\*1B = 1B，  
	   表示范围：0x00000000~0xffffffff
	* P=1，表示段存在
	* DPL=0，表示最高优先级
	* S=1，表示栈段
	* TYPE= 6，读写，向下扩展
	    
   **视频段描述符**：高32位：0x0040920b，低32位：0x80007fff
	* 段线性基地址：三部分组成，为0x000b8000
	* G=0，表示段界限以字节为单位
	* D/B=1，表示操作数大小为32位
	* L=0，表示32位代码
	* AVL，保留位，不关心，置0即可
	* 段界限由两部分组成，共20位。结合段界限和粒度，整个段长度为：  
	  最大偏移量 =（段界限+1）\* 粒度 = (0x07fff+1)\*4KB = 0x20000KB，  
	   表示范围：0x00000000~0x08000000
	* P=1，表示段存在
	* DPL=0，表示最高优先级
	* S=1，表示数据段
	* TYPE=   2，读写，向上扩展
1. 对于一个C/C++函数：int function(int a, int b):
	1. 在进入函数前先**传参**，若参数较少可以通过*寄存器传递*，如eax存储a的值，ebx存储b的值；若参数较多可以通过push*压栈传参*（从后往前），如push ebx，push eax（ebx存储了b的值，eax存储了a的值）
	2. **call** function调用函数（push eip，jmp function）
	3. 函数执行完之后**ret**返回，同时返回值一般存储在寄存器eax中，但若返回值过大(如c中的一个结构体)则会将返回值存储在内存中
	4. add esp，n（这里的n指进入函数前压入的参数所占的内内存大小），堆栈平衡

### **6. 总结**

在这一次lab中，我学会了LBA读写端口来实现读写磁盘；bootloader如何从从实模式到保护模式；以及将自己的汇编代码加到磁盘中，再读取到内存中执行。